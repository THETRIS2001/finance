<!DOCTYPE html>
<html lang="it">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rendimento Migliore Scelto un Periodo</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.4/moment.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-moment@1.0.1/dist/chartjs-adapter-moment.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>
    <script
        src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@2.1.0/dist/chartjs-plugin-annotation.min.js"></script>
    <style>
        .calculator-container {
            border-radius: 10px;
            background-color: #f8f9fa;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.08);
            padding: 25px;
            margin-bottom: 30px;
            transition: all 0.3s;
        }

        .calculator-container:hover {
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.12);
        }

        .input-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 25px;
            align-items: flex-start;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            position: relative;
            min-width: 200px;
            flex: 1;
        }

        .input-group:last-child {
            max-width: 150px;
        }

        .input-group label {
            font-weight: 600;
            margin-bottom: 8px;
            color: #444;
        }

        .input-group input,
        .input-group select {
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 12px 15px;
            font-size: 1rem;
            transition: all 0.2s;
        }

        .input-group input:focus,
        .input-group select:focus {
            border-color: #0080ff;
            box-shadow: 0 0 0 3px rgba(0, 128, 255, 0.2);
            outline: none;
        }

        .btn {
            padding: 12px 20px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            border: none;
            transition: all 0.2s;
            margin-top: 10px;
            background-color: #0080ff;
            color: white;
            width: 100%;
        }

        .btn:hover {
            background-color: #0066cc;
        }

        .loading-indicator {
            text-align: center;
            margin: 20px;
            display: none;
        }

        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #0080ff;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        .error-message {
            color: red;
            margin: 20px;
            padding: 15px;
            background-color: #ffeeee;
            border-radius: 8px;
            display: none;
        }

        .chart-wrapper {
            height: 700px;
            margin-bottom: 30px;
        }

        .stats-container {
            margin-top: 30px;
            padding: 20px;
            background-color: #f0f9ff;
            border-radius: 8px;
            border-left: 4px solid #0080ff;
        }

        .info-section {
            margin-top: 30px;
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }

        .info-card {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .info-card h3 {
            margin-top: 0;
            color: #333;
            font-size: 1.2rem;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        #periodi-container {
            width: 100%;
            max-width: 600px;
        }

        .periodo-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: center;
            flex-wrap: nowrap;
        }

        .periodo-row.aggiunto {
            background-color: #f0f9ff;
            border-radius: 8px;
            padding: 10px;
            border: 1px solid #d0e8ff;
            margin-top: 5px;
        }

        .periodo-row.aggiunto>div {
            flex: 1;
            display: flex;
            gap: 5px;
            min-width: 0;
        }

        .periodo-row.aggiunto .periodo-value {
            display: none;
        }

        .ticker-selection {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .ticker-selection select,
        .ticker-selection input {
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 12px 15px;
            font-size: 1rem;
            transition: all 0.2s;
        }

        .ticker-selection select:focus,
        .ticker-selection input:focus {
            border-color: #0080ff;
            box-shadow: 0 0 0 3px rgba(0, 128, 255, 0.2);
            outline: none;
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <h1>Rendimento Migliore Scelto un Periodo</h1>
        </header>
        <main>
            <a href="index.html" class="back-link">‚Üê Torna alla pagina principale</a>

            <div class="calculator-container">
                <h2>Analisi dei Rendimenti per Periodo</h2>
                <p>Questo strumento ti permette di analizzare i rendimenti ottenibili entrando nel mercato in diversi
                    momenti per specifici periodi di tempo.</p>

                <div class="input-grid">
                    <div class="input-group">
                        <label for="data_inizio">Data inizio dati:</label>
                        <div style="display: flex; width: 100%;">
                            <input type="date" id="data_inizio" value="2000-01-01"
                                style="flex-grow: 1; border-top-right-radius: 0; border-bottom-right-radius: 0;">
                            <button id="data_minima_btn"
                                style="border: 2px solid #e0e0e0; background-color: #f8f9fa; padding: 0 10px; border-left: none; border-top-right-radius: 8px; border-bottom-right-radius: 8px; cursor: pointer;"
                                title="Imposta alla data minima disponibile">
                                Min
                            </button>
                        </div>
                    </div>
                    <div class="input-group">
                        <label for="data_fine">Data fine dati:</label>
                        <input type="date" id="data_fine">
                    </div>
                    <div class="input-group" style="flex: 2;">
                        <label for="periodi_container">Periodi di investimento:</label>
                        <div id="periodi_container">
                            <div class="periodo-row">
                                <div style="display: flex; flex: 1; gap: 5px; min-width: 0;">
                                    <input type="number" class="periodo-input" data-unit="anni" placeholder="Anni"
                                        min="0"
                                        style="flex: 1; min-width: 100px; border: 2px solid #e0e0e0; border-radius: 8px; padding: 14px 15px; font-size: 1rem; height: 48px; box-sizing: border-box;">
                                    <input type="number" class="periodo-input" data-unit="mesi" placeholder="Mesi"
                                        min="0"
                                        style="flex: 1; min-width: 100px; border: 2px solid #e0e0e0; border-radius: 8px; padding: 14px 15px; font-size: 1rem; height: 48px; box-sizing: border-box;">
                                    <input type="number" class="periodo-input" data-unit="giorni" placeholder="Giorni"
                                        min="0"
                                        style="flex: 1; min-width: 100px; border: 2px solid #e0e0e0; border-radius: 8px; padding: 14px 15px; font-size: 1rem; height: 48px; box-sizing: border-box;">
                                </div>
                                <button class="add-periodo-btn"
                                    style="flex-shrink: 0; background-color: #0080ff; color: white; border: none; border-radius: 8px; padding: 14px; cursor: pointer; font-size: 1rem; height: 48px; box-sizing: border-box;">+</button>
                            </div>
                        </div>
                        <input type="hidden" id="periodi_investimento" value="">
                    </div>
                    <div class="input-group">
                        <label for="ticker">Ticker:</label>
                        <div class="ticker-selection">
                            <select id="ticker">
                                <option value="^GSPC">S&P 500</option>
                                <option value="AAPL">Apple Inc.</option>
                                <option value="MSFT">Microsoft Corporation</option>
                                <option value="AMZN">Amazon.com, Inc.</option>
                                <option value="GOOGL">Alphabet Inc. (Google)</option>
                                <option value="TSLA">Tesla, Inc.</option>
                                <option value="NVDA">Nvidia Corporation</option>
                                <option value="V">Visa Inc.</option>
                                <option value="JPM">JPMorgan Chase & Co.</option>
                                <option value="JNJ">Johnson & Johnson</option>
                                <option value="BRK-B">Berkshire Hathaway</option>
                                <option value="BTC-USD">Bitcoin</option>
                                <option value="GLD">Gold</option>
                                <option value="custom">Personalizzato</option>
                            </select>
                            <input type="text" id="ticker_custom" placeholder="Inserisci ticker" style="display: none;">
                        </div>
                    </div>
                    <div class="input-group">
                        <label for="leva">Leva:</label>
                        <input type="number" id="leva" value="1" min="0.1" max="100" step="0.1">
                    </div>
                </div>

                <button id="analizza" class="btn">Analizza Rendimenti</button>

                <div id="loading" class="loading-indicator" style="margin-top: 20px;">
                    <div class="spinner"></div>
                    <p>Caricamento dati in corso... Questo potrebbe richiedere alcuni secondi.</p>
                </div>

                <div id="error" class="error-message" style="margin-top: 20px;"></div>

                <div id="charts-container" style="display: none; margin-top: 20px;">
                    <div id="chart-wrapper-returns" class="chart-wrapper">
                        <div
                            style="display: flex; align-items: center; margin-bottom: 10px; justify-content: flex-end;">
                            <input type="checkbox" id="scala_logaritmica_rendimenti"
                                style="width: 18px; height: 18px; margin-right: 8px;">
                            <label for="scala_logaritmica_rendimenti" style="font-weight: 500; cursor: pointer;">Scala
                                logaritmica</label>
                        </div>
                        <canvas id="returnsChart"></canvas>
                    </div>

                    <div id="chart-wrapper-price" class="chart-wrapper">
                        <div
                            style="display: flex; align-items: center; margin-bottom: 10px; justify-content: flex-end;">
                            <input type="checkbox" id="scala_logaritmica_prezzo"
                                style="width: 18px; height: 18px; margin-right: 8px;">
                            <label for="scala_logaritmica_prezzo" style="font-weight: 500; cursor: pointer;">Scala
                                logaritmica</label>
                        </div>
                        <canvas id="priceChart"></canvas>
                    </div>

                    <div id="stats-container" class="stats-container">
                        <h2>Statistiche dei Rendimenti</h2>
                        <div
                            style="overflow-x: auto; width: 100%; -webkit-overflow-scrolling: touch; max-height: 600px; overflow-y: auto;">
                            <table id="stats-table" style="width: 100%; border-collapse: collapse; margin-top: 15px;">
                                <tbody id="stats-body">
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>

                <div class="info-section">
                    <h2>Note Importanti</h2>

                    <div class="info-card">
                        <h3>Interpretazione del Grafico dei Rendimenti</h3>
                        <p>Il primo grafico <strong>non mostra l'andamento dell'azione scelta</strong>, ma mostra il
                            <strong>risultato in percentuale</strong> di entrare nel mercato in quel momento specifico
                            per il periodo di tempo selezionato.
                        </p>
                    </div>

                    <div class="info-card">
                        <h3>Miglior Periodo di Investimento</h3>
                        <p>Il punto evidenziato in rosso rappresenta il momento di ingresso che avrebbe generato il
                            Rendimento Massimo nel periodo analizzato. Il punto blu rappresenta invece il momento con il
                            miglior rendimento annuo.</p>
                    </div>

                    <div class="info-card">
                        <h3>Rendimento Medio annuo realistico</h3>
                        <p>Questo valore √® calcolato escludendo il 20% dei rendimenti pi√π alti e pi√π bassi, fornendo una
                            stima pi√π realistica del rendimento atteso in condizioni di mercato normali.</p>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        // Variabili globali per i grafici
        let returnsChartInstance = null;
        let priceChartInstance = null;

        // Funzione per formattare il periodo in anni, mesi e giorni
        function formattaPeriodo(periodoAnni) {
            // Scomponiamo il periodo
            const anniInteri = Math.floor(periodoAnni);
            const meseDecimale = (periodoAnni - anniInteri) * 12;
            const mesiInteri = Math.floor(meseDecimale);
            const giorni = Math.round((meseDecimale - mesiInteri) * 30.4375); // Media giorni per mese

            // Formattiamo il testo
            let periodoTesto = '';
            if (anniInteri > 0) periodoTesto += anniInteri + (anniInteri === 1 ? ' anno ' : ' anni ');
            if (mesiInteri > 0) periodoTesto += mesiInteri + (mesiInteri === 1 ? ' mese ' : ' mesi ');
            if (giorni > 0) periodoTesto += giorni + (giorni === 1 ? ' giorno' : ' giorni');

            // Se periodo √® molto breve (meno di un giorno)
            if (periodoTesto === '') periodoTesto = 'meno di 1 giorno';

            return periodoTesto.trim();
        }

        // Inizializzazione al caricamento della pagina
        document.addEventListener('DOMContentLoaded', function () {
            // Impostiamo la data di fine al giorno corrente
            const oggi = new Date();
            document.getElementById('data_fine').valueAsDate = oggi;

            // Aggiungiamo l'event listener per il pulsante di analisi
            document.getElementById('analizza').addEventListener('click', analizza);

            // Aggiungiamo l'event listener per il pulsante data minima
            document.getElementById('data_minima_btn').addEventListener('click', trovaDataMinima);

            // Gestione ticker personalizzato
            const tickerSelect = document.getElementById('ticker');
            const tickerCustomInput = document.getElementById('ticker_custom');

            tickerSelect.addEventListener('change', function () {
                if (this.value === 'custom') {
                    tickerCustomInput.style.display = 'block';
                } else {
                    tickerCustomInput.style.display = 'none';
                }
            });

            // Aggiungiamo l'event listener per il checkbox della scala logaritmica del prezzo
            document.getElementById('scala_logaritmica_prezzo').addEventListener('change', function () {
                if (priceChartInstance) {
                    // Modifichiamo la scala dell'asse Y
                    priceChartInstance.options.scales.y.type = this.checked ? 'logarithmic' : 'linear';
                    priceChartInstance.update();
                }
            });

            // Aggiungiamo l'event listener per il checkbox della scala logaritmica dei rendimenti
            document.getElementById('scala_logaritmica_rendimenti').addEventListener('change', function () {
                if (returnsChartInstance) {
                    // Modifichiamo la scala dell'asse Y
                    returnsChartInstance.options.scales.y.type = this.checked ? 'logarithmic' : 'linear';
                    returnsChartInstance.update();
                }
            });

            // Inizializzazione gestione periodi
            initPeriodi();

            // Eseguiamo l'analisi all'avvio della pagina
            setTimeout(analizza, 0);
        });

        // Funzione per trovare la data minima disponibile per il ticker selezionato
        async function trovaDataMinima() {
            try {

                // Mostriamo il loader
                document.getElementById('loading').style.display = 'block';
                document.getElementById('error').style.display = 'none';

                let ticker = document.getElementById('ticker').value;
                // Se il ticker √® personalizzato, usa il valore dell'input
                if (ticker === 'custom') {
                    ticker = document.getElementById('ticker_custom').value.trim();
                    if (!ticker) {
                        throw new Error('Inserisci un ticker valido nel campo personalizzato');
                    }
                }

                // Data di partenza molto vecchia per assicurarci di ottenere tutti i dati
                const dataVecchia = new Date('1950-01-01');
                const oggi = new Date();

                // Costruiamo l'URL per l'API di Yahoo Finance usando il formato chart
                const period1 = Math.floor(dataVecchia.getTime() / 1000);
                const period2 = Math.floor(oggi.getTime() / 1000);
                const yahooUrl = `https://query1.finance.yahoo.com/v7/finance/chart/${ticker}?period1=${period1}&period2=${period2}&interval=1d&events=history`;

                const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(yahooUrl)}`;

                const response = await fetch(proxyUrl);
                const parsedData = await response.json();

                if (!parsedData.chart || !parsedData.chart.result || parsedData.chart.result.length === 0) {
                    throw new Error('Dati non disponibili');
                }

                const result = parsedData.chart.result[0];
                const timestamps = result.timestamp;

                if (timestamps && timestamps.length > 0) {
                    // Il primo timestamp √® la data pi√π vecchia disponibile
                    const dataMinima = new Date(timestamps[0] * 1000);

                    // Formatta la data nel formato YYYY-MM-DD per l'input date
                    const dataFormattata = dataMinima.toISOString().split('T')[0];
                    document.getElementById('data_inizio').value = dataFormattata;

                    // Nascondiamo il loader
                    document.getElementById('loading').style.display = 'none';

                    // Eseguiamo l'analisi con la nuova data
                    analizza();
                } else {
                    throw new Error('Nessun dato disponibile per questo ticker');
                }
            } catch (error) {
                console.error('Errore nel recupero della data minima:', error);
                document.getElementById('loading').style.display = 'none';
                document.getElementById('error').style.display = 'block';
                document.getElementById('error').innerHTML = `<p>Errore nel recupero della data minima: ${error.message}</p>`;
            }
        }

        // Funzione per formattare le date
        function formatDate(date) {
            return date.toISOString().split('T')[0];
        }

        // Funzione principale per analizzare i rendimenti
        async function analizza() {
            try {
                // Mostriamo il loader
                document.getElementById('loading').style.display = 'block';
                document.getElementById('error').style.display = 'none';
                document.getElementById('charts-container').style.display = 'none';

                // Otteniamo i parametri dall'interfaccia
                const dataInizio = document.getElementById('data_inizio').value;
                let ticker = document.getElementById('ticker').value;
                // Se il ticker √® personalizzato, usa il valore dell'input
                if (ticker === 'custom') {
                    ticker = document.getElementById('ticker_custom').value.trim();
                    if (!ticker) {
                        throw new Error('Inserisci un ticker valido nel campo personalizzato');
                    }
                }

                // Recuperiamo i dati storici (questo gi√† include il trovaMigliorPeriodoGlobale)
                const datiStorici = await fetchStockData(ticker, dataInizio);

                // Non serve chiamare esplicitamente trovaMigliorPeriodoGlobale qui
                // perch√© viene gi√† chiamato all'interno di fetchStockData
            } catch (error) {
                console.error('Errore nell\'analisi:', error);
                document.getElementById('loading').style.display = 'none';
                document.getElementById('error').style.display = 'block';
                document.getElementById('error').innerHTML = `<p>Errore nell'analisi: ${error.message}</p>`;
            }
        }

        // Funzione per calcolare il tasso annuo medio
        function calcolaTassoAnnuo(iniziale, finale, anni) {
            return Math.pow(finale / iniziale, 1 / anni) - 1;
        }

        // Funzione per ottenere i dati storici da Yahoo Finance
        async function fetchStockData(ticker, startDate) {
            try {
                // Utilizziamo l'API di Yahoo Finance tramite proxy per evitare problemi CORS
                const endDate = document.getElementById('data_fine').value ? new Date(document.getElementById('data_fine').value) : new Date();
                const startDateFormatted = formatDate(new Date(startDate));
                const endDateFormatted = formatDate(endDate);

                // Costruiamo l'URL per l'API di Yahoo Finance usando il formato chart
                const period1 = Math.floor(new Date(startDateFormatted).getTime() / 1000);
                const period2 = Math.floor(endDate.getTime() / 1000);
                const yahooUrl = `https://query1.finance.yahoo.com/v7/finance/chart/${ticker}?period1=${period1}&period2=${period2}&interval=1d&events=history`;

                const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(yahooUrl)}`;
                /*const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(yahooUrl)}`;*/

                // Mostriamo il loader durante il caricamento
                document.getElementById('loading').style.display = 'block';
                document.getElementById('error').style.display = 'none';

                const response = await fetch(proxyUrl);
                const parsedData = await response.json();

                if (!parsedData.chart || !parsedData.chart.result || parsedData.chart.result.length === 0) {
                    throw new Error('Dati non disponibili');
                }

                const result = parsedData.chart.result[0];
                const timestamps = result.timestamp;
                const quotes = result.indicators.quote[0];
                const closePrices = quotes.close;

                // Creiamo un array di dati nel formato atteso da processStockData
                const data = [];
                for (let i = 0; i < timestamps.length; i++) {
                    if (closePrices[i] !== null) {
                        data.push({
                            Date: new Date(timestamps[i] * 1000).toISOString().split('T')[0],
                            Close: closePrices[i]
                        });
                    }
                }

                // Prima troviamo il miglior periodo globale
                const migliorPeriodoGlobale = await trovaMigliorPeriodoGlobale(data);

                // Poi processiamo i dati (incluso il miglior periodo globale)
                processStockData(data);
                return data;
            } catch (error) {
                console.error('Errore nel recupero dei dati:', error);
                document.getElementById('loading').style.display = 'none';
                document.getElementById('error').style.display = 'block';
                document.getElementById('error').innerHTML = `<p>Errore nel recupero dei dati: ${error.message}</p>`;
                throw error;
            }
        }

        // Funzione per gestire il caricamento del file CSV
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function (e) {
                    const csvData = e.target.result;
                    // Utilizziamo PapaParse per analizzare il CSV
                    Papa.parse(csvData, {
                        header: true,
                        dynamicTyping: true,
                        complete: function (results) {
                            // Nascondiamo il messaggio di errore
                            document.getElementById('error').style.display = 'none';
                            // Processiamo i dati
                            processStockData(results.data);
                        },
                        error: function (error) {
                            console.error('Errore nell\'analisi del CSV:', error);
                            document.getElementById('error').style.display = 'block';
                            document.getElementById('error').innerHTML = `<p>Errore nell'analisi del file CSV: ${error.message}</p>`;
                        }
                    });
                };
                reader.readAsText(file);
            }
        }

        // Funzione per processare i dati delle azioni
        function processStockData(data) {
            try {
                // Nascondiamo il loader
                document.getElementById('loading').style.display = 'none';

                // Otteniamo i parametri dall'interfaccia
                const periodiInput = document.getElementById('periodi_investimento').value;
                // Dividiamo i periodi separati da virgola e convertiamo in numeri
                const periodiAnni = periodiInput.split(',').map(periodo => parseFloat(periodo.trim())).filter(periodo => !isNaN(periodo));
                const leva = parseFloat(document.getElementById('leva').value);

                // Filtriamo i dati per rimuovere eventuali righe incomplete
                data = data.filter(row => row.Date && row.Close);

                // Ordiniamo i dati per data
                data.sort((a, b) => new Date(a.Date) - new Date(b.Date));

                // Calcoliamo i rendimenti giornalieri
                const closePrices = data.map(row => row.Close || row['Adj Close']);
                const dates = data.map(row => new Date(row.Date));

                // Calcoliamo i rendimenti giornalieri
                const dailyReturns = [];
                for (let i = 1; i < closePrices.length; i++) {
                    dailyReturns.push((closePrices[i] / closePrices[i - 1]) - 1);
                }

                // Applichiamo la leva ai rendimenti giornalieri
                const leveragedReturns = dailyReturns.map(ret => leva * ret);

                // Calcoliamo il valore cumulativo con leva
                const leveragedData = [100]; // Partiamo da 100
                for (let i = 0; i < leveragedReturns.length; i++) {
                    leveragedData.push(leveragedData[leveragedData.length - 1] * (1 + leveragedReturns[i]));
                }

                // Creiamo un array per contenere i risultati di tutti i periodi
                const tuttiRendimenti = [];
                const tuttiMiglioriGiorni = [];
                const tuttiMiglioriGiorniAnnui = [];

                // Per ogni periodo di investimento specificato
                for (let p = 0; p < periodiAnni.length; p++) {
                    const periodoAnni = periodiAnni[p];

                    // Calcoliamo il numero di giorni di calendario
                    const dataInizioObj = new Date(data[0].Date);
                    let dataFineObj = new Date(dataInizioObj);

                    // Scomponiamo il periodo in anni, mesi e giorni
                    const anniInteri = Math.floor(periodoAnni);
                    const meseDecimale = (periodoAnni - anniInteri) * 12;
                    const mesiInteri = Math.floor(meseDecimale);
                    const giorni = Math.round((meseDecimale - mesiInteri) * 30.4375); // Media giorni per mese

                    // Applichiamo il periodo alla data di inizio
                    dataFineObj.setFullYear(dataFineObj.getFullYear() + anniInteri);
                    dataFineObj.setMonth(dataFineObj.getMonth() + mesiInteri);
                    dataFineObj.setDate(dataFineObj.getDate() + giorni);

                    // Per la visualizzazione
                    const periodoMesi = anniInteri * 12 + mesiInteri;

                    // Calcoliamo quanti giorni di trading ci sono tra le due date
                    // Troviamo gli indici delle date pi√π vicine nel nostro dataset
                    let indiceFine = -1;
                    let distanzaMinima = Infinity;

                    for (let i = 0; i < dates.length; i++) {
                        const diffMs = Math.abs(dates[i].getTime() - dataFineObj.getTime());
                        if (diffMs < distanzaMinima) {
                            distanzaMinima = diffMs;
                            indiceFine = i;
                        }
                    }

                    // Se non abbiamo trovato una data fine valida, saltiamo questo periodo
                    if (indiceFine < 0) continue;

                    // Calcoliamo il numero di giorni di trading
                    const giorni_investimento = indiceFine;
                    const rendimenti = {};

                    for (let i = 0; i < leveragedData.length; i++) {
                        if (i + giorni_investimento < leveragedData.length) {
                            const data_ingresso = dates[i];
                            const data_uscita = dates[i + giorni_investimento];
                            const prezzo_ingresso = leveragedData[i];
                            const prezzo_uscita = leveragedData[i + giorni_investimento];
                            const rendimento = ((prezzo_uscita / prezzo_ingresso) - 1) * 100;
                            rendimenti[data_ingresso] = { rendimento, data_uscita };
                        }
                    }

                    // Convertiamo i rendimenti in un array per l'analisi
                    const rendimentiArray = Object.entries(rendimenti).map(([data_ingresso, { rendimento, data_uscita }]) => {
                        return {
                            data_ingresso: new Date(data_ingresso),
                            rendimento,
                            data_uscita: new Date(data_uscita),
                            periodo: periodoAnni
                        };
                    });

                    // Calcoliamo le statistiche
                    const rendimentiValues = rendimentiArray.map(r => r.rendimento);
                    const negative_pct = (rendimentiValues.filter(r => r < 0).length / rendimentiValues.length) * 100;
                    const max_ret = Math.max(...rendimentiValues);
                    const min_ret = Math.min(...rendimentiValues);
                    const mean_ret = rendimentiValues.reduce((a, b) => a + b, 0) / rendimentiValues.length;

                    // Calcoliamo il rendimento annuo medio
                    const rendimento_annuo_medio = ((1 + mean_ret / 100) ** (1 / periodoAnni) - 1) * 100;

                    // Calcoliamo il Rendimento Minimo annuo
                    const rendimento_minimo_annuo = ((1 + min_ret / 100) ** (1 / periodoAnni) - 1) * 100;

                    // Calcoliamo il rendimento annuo medio realistico (escludendo il 20% dei rendimenti pi√π alti e pi√π bassi)
                    const sortedReturns = [...rendimentiValues].sort((a, b) => a - b);
                    const lowerBoundIndex = Math.floor(sortedReturns.length * 0.2);
                    const upperBoundIndex = Math.floor(sortedReturns.length * 0.8);
                    const filteredReturns = sortedReturns.slice(lowerBoundIndex, upperBoundIndex);
                    const filteredMeanRet = filteredReturns.reduce((a, b) => a + b, 0) / filteredReturns.length;
                    const rendimento_annuo_medio_realistico = ((1 + filteredMeanRet / 100) ** (1 / periodoAnni) - 1) * 100;

                    // Troviamo il miglior giorno d'ingresso (Rendimento Massimo)
                    const migliorRendimentoIndex = rendimentiValues.indexOf(max_ret);
                    const migliorGiorno = rendimentiArray[migliorRendimentoIndex]?.data_ingresso;
                    const migliorDataUscita = rendimentiArray[migliorRendimentoIndex]?.data_uscita;
                    const migliorRendimento = max_ret;
                    const rendimentoAnnuo = ((1 + migliorRendimento / 100) ** (1 / periodoAnni) - 1) * 100;

                    // Troviamo il miglior giorno d'ingresso per rendimento annuo
                    const rendimentiAnnui = rendimentiArray.map(r => {
                        return {
                            ...r,
                            rendimento_annuo: ((1 + r.rendimento / 100) ** (1 / periodoAnni) - 1) * 100
                        };
                    });

                    const maxRendimentoAnnuo = Math.max(...rendimentiAnnui.map(r => r.rendimento_annuo));
                    const migliorGiornoAnnuoIndex = rendimentiAnnui.findIndex(r => r.rendimento_annuo === maxRendimentoAnnuo);
                    const migliorGiornoAnnuo = rendimentiAnnui[migliorGiornoAnnuoIndex]?.data_ingresso;
                    const migliorDataUscitaAnnuo = rendimentiAnnui[migliorGiornoAnnuoIndex]?.data_uscita;
                    const migliorRendimentoAnnuo = rendimentiAnnui[migliorGiornoAnnuoIndex]?.rendimento;

                    // Aggiungiamo i risultati di questo periodo all'array di tutti i rendimenti
                    tuttiRendimenti.push({
                        periodo: periodoAnni,
                        rendimentiArray: rendimentiArray,
                        stats: {
                            periodoMesi: periodoMesi.toFixed(1),
                            periodoAnni: periodoAnni.toFixed(2),
                            negative_pct: negative_pct.toFixed(2) + '%',
                            max_ret: max_ret.toFixed(2) + '%',
                            min_ret: min_ret.toFixed(2) + '%',
                            mean_ret: mean_ret.toFixed(2) + '%',
                            rendimento_annuo_medio: rendimento_annuo_medio.toFixed(2) + '% / annuo',
                            rendimento_minimo_annuo: rendimento_minimo_annuo.toFixed(2) + '% / annuo',
                            rendimento_annuo_medio_realistico: rendimento_annuo_medio_realistico.toFixed(2) + '% / annuo'
                        }
                    });

                    // Aggiungiamo i migliori giorni per questo periodo
                    if (migliorGiorno && migliorDataUscita) {
                        tuttiMiglioriGiorni.push({
                            periodo: periodoAnni,
                            giorno: migliorGiorno,
                            dataUscita: migliorDataUscita,
                            rendimento: migliorRendimento,
                            rendimentoAnnuo: rendimentoAnnuo
                        });
                    }

                    if (migliorGiornoAnnuo && migliorDataUscitaAnnuo) {
                        tuttiMiglioriGiorniAnnui.push({
                            periodo: periodoAnni,
                            giorno: migliorGiornoAnnuo,
                            dataUscita: migliorDataUscitaAnnuo,
                            rendimento: migliorRendimentoAnnuo,
                            rendimentoAnnuo: maxRendimentoAnnuo
                        });
                    }
                } // Fine del ciclo per ogni periodo

                // Mostriamo i grafici con tutti i periodi
                createReturnsChart(tuttiRendimenti, tuttiMiglioriGiorni, tuttiMiglioriGiorniAnnui);
                createPriceChart(dates, leveragedData, tuttiMiglioriGiorni, tuttiMiglioriGiorniAnnui);

                // Aggiorniamo la tabella delle statistiche con tutti i periodi in formato tabellare
                if (tuttiRendimenti.length > 0) {
                    // Creiamo un array di oggetti con le statistiche per ogni periodo
                    const statsArray = [];

                    for (let i = 0; i < tuttiRendimenti.length; i++) {
                        const periodoStats = tuttiRendimenti[i].stats;
                        const periodo = tuttiRendimenti[i].periodo;
                        const migliorGiorno = tuttiMiglioriGiorni.find(mg => mg.periodo === periodo);
                        // Creiamo un oggetto con le statistiche di base per questo periodo
                        const periodoObj = {
                            'Periodo': formattaPeriodo(periodo),
                            'periodoRaw': periodo, // Valore numerico per ordinamento
                            'isPeriodoGlobale': false, // Flag per il periodo massimo globale
                            'Giorni negativi': periodoStats.negative_pct,
                            'Rendimento Massimo': periodo === 1 ?
                                `${formatRendimento(parseFloat(periodoStats.max_ret))}` :
                                `${formatRendimento(parseFloat(periodoStats.max_ret))} (${formatRendimento(migliorGiorno ? migliorGiorno.rendimentoAnnuo : 0, true)})`,
                            'Rendimento Minimo': periodo === 1 ?
                                `${formatRendimento(parseFloat(periodoStats.min_ret))}` :
                                `${formatRendimento(parseFloat(periodoStats.min_ret))} (${formatRendimento(parseFloat(periodoStats.rendimento_minimo_annuo), true)})`,
                            'Rendimento Medio': periodo === 1 ?
                                `${formatRendimento(parseFloat(periodoStats.mean_ret))} (${formatRendimento(parseFloat(periodoStats.rendimento_annuo_medio_realistico), true)} realistico)` :
                                `${formatRendimento(parseFloat(periodoStats.mean_ret))} (${formatRendimento(parseFloat(periodoStats.rendimento_annuo_medio), true)} ‚óæ ${formatRendimento(parseFloat(periodoStats.rendimento_annuo_medio_realistico), true)} realistico)`,
                            'Miglior data ingresso': migliorGiorno ? migliorGiorno.giorno.toLocaleDateString() : '-',
                            'Miglior data uscita': migliorGiorno ? migliorGiorno.dataUscita.toLocaleDateString() : '-'
                        };

                        // Verifichiamo se questo periodo √® il periodo massimo globale
                        const periodoRowGlobale = document.querySelector('.periodo-row.miglior-periodo-globale .periodo-value');
                        if (periodoRowGlobale) {
                            const anniGlobale = parseFloat(periodoRowGlobale.getAttribute('data-anni') || 0);
                            const mesiGlobale = parseFloat(periodoRowGlobale.getAttribute('data-mesi') || 0);
                            const giorniGlobale = parseFloat(periodoRowGlobale.getAttribute('data-giorni') || 0);
                            const periodoGlobale = anniGlobale + (mesiGlobale / 12) + (giorniGlobale / 365.25);

                            // Se questo periodo corrisponde al periodo massimo globale, lo flagghiamo
                            if (Math.abs(periodo - periodoGlobale) < 0.001) { // Tolleranza per errori di arrotondamento
                                periodoObj.isPeriodoGlobale = true;
                            }
                        }

                        // Funzione per formattare il rendimento con segno + se positivo
                        function formatRendimento(valore, isAnnuo = false) {
                            if (isNaN(valore)) return '-';
                            const segno = valore > 0 ? '+' : '';
                            // Arrotondiamo a 2 cifre decimali
                            const valoreArrotondato = parseFloat(valore).toFixed(2);
                            return isAnnuo ? `${segno}${valoreArrotondato}% / anno` : `${segno}${valoreArrotondato}%`;
                        }

                        // Aggiungiamo informazioni sui migliori giorni per questo periodo

                        if (migliorGiorno) {
                            periodoObj['Miglior data ingresso'] = migliorGiorno.giorno.toLocaleDateString();
                            periodoObj['Miglior data uscita'] = migliorGiorno.dataUscita.toLocaleDateString();
                        }

                        // Aggiungiamo informazioni sui migliori giorni per rendimento annuo
                        const migliorGiornoAnnuo = tuttiMiglioriGiorniAnnui.find(mg => mg.periodo === periodo);

                        statsArray.push(periodoObj);
                    }

                    updateStatsTable(statsArray);
                }

                // Mostriamo il container dei grafici
                document.getElementById('charts-container').style.display = 'block';
            } catch (error) {
                console.error('Errore nell\'elaborazione dei dati:', error);
                document.getElementById('error').style.display = 'block';
                document.getElementById('error').innerHTML = `<p>Errore nell'elaborazione dei dati: ${error.message}</p>`;
            }
        }

        // Funzione per trovare il miglior periodo di investimento globale
        async function trovaMigliorPeriodoGlobale(data) {
            try {
                // Prima rimuoviamo eventuali periodi ottimali preesistenti
                document.querySelectorAll('.periodo-row.miglior-periodo-globale').forEach(el => el.remove());

                // Assicuriamoci che i dati siano ordinati per data
                data.sort((a, b) => new Date(a.Date) - new Date(b.Date));

                const dates = data.map(row => new Date(row.Date));
                const closePrices = data.map(row => row.Close || row['Adj Close']);

                // Otteniamo il valore della leva
                const leva = parseFloat(document.getElementById('leva').value);

                // Troviamo il minimo e massimo globale per riferimento
                const prezzoMinimo = Math.min(...closePrices);
                const prezzoMassimo = Math.max(...closePrices);
                const indicePrezzoMinimo = closePrices.indexOf(prezzoMinimo);
                const indicePrezzoMassimo = closePrices.indexOf(prezzoMassimo);
                const dataPrezzoMinimo = dates[indicePrezzoMinimo];
                const dataPrezzoMassimo = dates[indicePrezzoMassimo];

                // Approccio corretto: vogliamo trovare il miglior rendimento possibile comprando al minimo e vendendo al massimo
                // ma dobbiamo rispettare l'ordine temporale (compriamo prima, vendiamo dopo)

                let migliorRendimento = -Infinity;
                let migliorDataInizio = null;
                let migliorDataFine = null;
                let migliorDurataGiorni = 0;
                let migliorIndiceInizio = -1;
                let migliorIndiceFine = -1;
                let migliorPrezzoAcquisto = 0;
                let migliorPrezzoVendita = 0;

                // Attraversiamo tutte le coppie di date (i,j) dove i < j (compriamo prima di vendere)
                for (let i = 0; i < closePrices.length - 1; i++) {
                    const prezzoAcquisto = closePrices[i];

                    // Per ogni data di acquisto, verifichiamo se √® il minimo da quella data in poi
                    let minimoLocale = prezzoAcquisto;
                    let indiceMinimoLocale = i;

                    for (let k = i + 1; k < closePrices.length; k++) {
                        if (closePrices[k] < minimoLocale) {
                            minimoLocale = closePrices[k];
                            indiceMinimoLocale = k;
                        }
                    }

                    // Se esiste un prezzo pi√π basso dopo l'attuale, non ha senso comprare ora
                    if (indiceMinimoLocale > i) {
                        continue;
                    }

                    // Cerchiamo il prezzo massimo dopo la data di acquisto
                    let massimoLocale = prezzoAcquisto;
                    let indiceMassimoLocale = i;

                    for (let j = i + 1; j < closePrices.length; j++) {
                        const prezzoVendita = closePrices[j];

                        // Teniamo traccia del massimo locale
                        if (prezzoVendita > massimoLocale) {
                            massimoLocale = prezzoVendita;
                            indiceMassimoLocale = j;
                        }

                        // Calcoliamo il rendimento base (no leva)
                        let rendimentoBase = (prezzoVendita / prezzoAcquisto) - 1;

                        // Se la leva √® maggiore di 1, dobbiamo calcolare il rendimento con leva correttamente
                        // Non possiamo semplicemente moltiplicare il rendimento finale per la leva
                        // Dobbiamo simulare l'effetto composto della leva sui rendimenti giornalieri

                        // Se la leva √® diversa da 1, calcoliamo il rendimento con leva correttamente
                        let rendimentoFinale;
                        if (leva !== 1) {
                            // Estrai i rendimenti giornalieri in questo intervallo
                            const rendimentiGiornalieri = [];
                            for (let k = i; k < j; k++) {
                                if (k + 1 < closePrices.length) {
                                    const rendimentoGiornaliero = (closePrices[k + 1] / closePrices[k]) - 1;
                                    rendimentiGiornalieri.push(rendimentoGiornaliero);
                                }
                            }

                            // Applica la leva ai rendimenti giornalieri
                            const rendimentiConLeva = rendimentiGiornalieri.map(r => r * leva);

                            // Calcola il rendimento composto
                            let valoreConLeva = 1;
                            for (const r of rendimentiConLeva) {
                                valoreConLeva *= (1 + r);
                            }

                            rendimentoFinale = (valoreConLeva - 1) * 100;
                        } else {
                            // Se la leva √® 1, usiamo direttamente il rendimento base
                            rendimentoFinale = rendimentoBase * 100;
                        }

                        // Verifichiamo se √® il miglior rendimento finora
                        if (rendimentoFinale > migliorRendimento) {
                            migliorRendimento = rendimentoFinale;
                            migliorDataInizio = dates[i];
                            migliorDataFine = dates[j];
                            migliorDurataGiorni = j - i;
                            migliorIndiceInizio = i;
                            migliorIndiceFine = j;
                            migliorPrezzoAcquisto = prezzoAcquisto;
                            migliorPrezzoVendita = prezzoVendita;
                        }
                    }
                }

                // Se non abbiamo trovato un buon rendimento, potrebbe essere un problema con i dati
                if (migliorRendimento === -Infinity) {
                    console.error("Non √® stato possibile trovare un rendimento positivo");
                    return null;
                }

                // Verifica se abbiamo acquistato al minimo locale e venduto al massimo locale
                let √®Minimo = true;
                let √®Massimo = true;

                // Verifichiamo se il prezzo di acquisto √® il minimo nel periodo da inizio a fine
                for (let i = 0; i < migliorIndiceInizio; i++) {
                    if (closePrices[i] < migliorPrezzoAcquisto) {
                        √®Minimo = false;
                        break;
                    }
                }

                // Verifichiamo se il prezzo di vendita √® il massimo nel periodo considerato
                for (let i = migliorIndiceInizio; i <= migliorIndiceFine; i++) {
                    if (closePrices[i] > migliorPrezzoVendita) {
                        √®Massimo = false;
                        break;
                    }
                }

                // Calcoliamo la durata in anni
                const durataAnni = migliorDurataGiorni / 365.25;

                // Convertiamo in anni, mesi e giorni
                const anni = Math.floor(durataAnni);
                const meseDecimale = (durataAnni - anni) * 12;
                const mesi = Math.floor(meseDecimale);
                const giorni = Math.round((meseDecimale - mesi) * 30.4375);

                // Calcoliamo la durata in modo pi√π preciso usando le date effettive
                const diffTime = Math.abs(migliorDataFine - migliorDataInizio);
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

                // Calcolo pi√π preciso degli anni, mesi, giorni
                let dataTemp = new Date(migliorDataInizio);
                let anniEsatti = 0;

                // Contiamo gli anni interi
                while (true) {
                    dataTemp.setFullYear(dataTemp.getFullYear() + 1);
                    if (dataTemp <= migliorDataFine) {
                        anniEsatti++;
                    } else {
                        dataTemp.setFullYear(dataTemp.getFullYear() - 1);
                        break;
                    }
                }

                // Contiamo i mesi interi
                let mesiEsatti = 0;
                while (true) {
                    dataTemp.setMonth(dataTemp.getMonth() + 1);
                    if (dataTemp <= migliorDataFine) {
                        mesiEsatti++;
                    } else {
                        dataTemp.setMonth(dataTemp.getMonth() - 1);
                        break;
                    }
                }

                // Contiamo i giorni rimanenti
                let giorniEsatti = 0;
                while (true) {
                    dataTemp.setDate(dataTemp.getDate() + 1);
                    if (dataTemp <= migliorDataFine) {
                        giorniEsatti++;
                    } else {
                        break;
                    }
                }

                // Usiamo il calcolo esatto
                const anniFinali = anniEsatti;
                const mesiFinali = mesiEsatti;
                const giorniFinali = giorniEsatti;

                // Aggiungiamo il periodo ottimale all'input hidden
                const durataAnniPrecisa = durataAnni.toFixed(4);
                let periodiAttuali = document.getElementById('periodi_investimento').value;
                // Verifichiamo se esiste gi√† questo periodo
                const periodiArray = periodiAttuali.split(',').map(p => parseFloat(p.trim())).filter(p => !isNaN(p));
                if (!periodiArray.includes(parseFloat(durataAnniPrecisa))) {
                    if (periodiAttuali) {
                        periodiAttuali += ',';
                    }
                    periodiAttuali += durataAnniPrecisa;
                    document.getElementById('periodi_investimento').value = periodiAttuali;
                }

                // Aggiungiamo visualmente il periodo all'interfaccia
                const periodoOttimale = document.createElement('div');
                periodoOttimale.className = 'periodo-row aggiunto miglior-periodo-globale';
                periodoOttimale.style.display = 'flex';
                periodoOttimale.style.alignItems = 'center';
                periodoOttimale.style.backgroundColor = '#e6f2ff'; // Blu chiaro
                periodoOttimale.style.border = '1px solid #99ccff'; // Bordo blu

                let periodoTesto = 'Miglior Periodo Globale';
                periodoTesto += ': ';

                if (anniFinali > 0) periodoTesto += anniFinali + (anniFinali === 1 ? ' anno ' : ' anni ');
                if (mesiFinali > 0) periodoTesto += mesiFinali + (mesiFinali === 1 ? ' mese ' : ' mesi ');
                if (giorniFinali > 0) periodoTesto += giorniFinali + (giorniFinali === 1 ? ' giorno' : ' giorni');

                periodoOttimale.innerHTML = `
                    <div style="flex: 1; font-weight: 600; color: #0066cc;">${periodoTesto}</div>
                    <input type="hidden" class="periodo-value" data-anni="${anniFinali}" data-mesi="${mesiFinali}" data-giorni="${giorniFinali}">
                    <button class="remove-periodo-btn" style="background-color: #dc3545; color: white; border: none; border-radius: 8px; padding: 8px 12px; cursor: pointer; margin-left: 10px;">√ó</button>
                `;

                // Aggiungiamo dopo tutti gli altri periodi
                const periodiContainer = document.getElementById('periodi_container');
                periodiContainer.appendChild(periodoOttimale);

                // Aggiungiamo l'event listener per il pulsante di rimozione
                periodoOttimale.querySelector('.remove-periodo-btn').addEventListener('click', function () {
                    periodoOttimale.remove();
                    aggiornaCampoPeriodi();
                });

                // Aggiorniamo il campo nascosto con i periodi
                aggiornaCampoPeriodi();

                return {
                    durataAnni: durataAnni,
                    rendimento: migliorRendimento,
                    dataInizio: migliorDataInizio,
                    dataFine: migliorDataFine,
                    indiceInizio: migliorIndiceInizio,
                    indiceFine: migliorIndiceFine,
                    leva: leva
                };
            } catch (error) {
                console.error('Errore nel calcolo del miglior periodo globale:', error);
                document.getElementById('error').style.display = 'block';
                document.getElementById('error').innerHTML += `<p>Errore nel calcolo del miglior periodo globale: ${error.message}</p>`;
                return null;
            }
        }

        // Funzione per creare il grafico dei rendimenti
        function createReturnsChart(tuttiRendimenti, tuttiMiglioriGiorni, tuttiMiglioriGiorniAnnui) {
            // Distruggiamo il grafico esistente se presente
            if (returnsChartInstance) {
                returnsChartInstance.destroy();
            }

            // Assicuriamoci che il container dei grafici sia visibile
            document.getElementById('charts-container').style.display = 'block';

            // Verifichiamo se la scala logaritmica √® attiva
            const usaScalaLogaritmica = document.getElementById('scala_logaritmica_rendimenti').checked;

            // Creiamo il nuovo grafico
            const ctx = document.getElementById('returnsChart').getContext('2d');

            // Colori predefiniti per i diversi periodi
            const colors = [
                { bg: 'rgba(0, 123, 255, 0.5)', border: 'rgba(0, 123, 255, 1)' },  // Blu
                { bg: 'rgba(40, 167, 69, 0.5)', border: 'rgba(40, 167, 69, 1)' },    // Verde
                { bg: 'rgba(220, 53, 69, 0.5)', border: 'rgba(220, 53, 69, 1)' },     // Rosso
                { bg: 'rgba(255, 193, 7, 0.5)', border: 'rgba(255, 193, 7, 1)' },     // Giallo
                { bg: 'rgba(111, 66, 193, 0.5)', border: 'rgba(111, 66, 193, 1)' },   // Viola
                { bg: 'rgba(23, 162, 184, 0.5)', border: 'rgba(23, 162, 184, 1)' }     // Ciano
            ];

            // Prepariamo i dataset per ogni periodo
            const datasets = [];

            // Aggiungiamo un dataset per ogni periodo (solo le linee di rendimento)
            for (let i = 0; i < tuttiRendimenti.length; i++) {
                const periodo = tuttiRendimenti[i].periodo;
                const rendimentiArray = tuttiRendimenti[i].rendimentiArray;
                const colorIndex = i % colors.length;

                // Formattiamo il periodo in anni, mesi e giorni
                const periodoFormattato = formattaPeriodo(periodo);

                // Dataset per i rendimenti di questo periodo
                datasets.push({
                    label: `Rendimenti (${periodoFormattato})`,
                    data: rendimentiArray.map(r => ({
                        x: r.data_ingresso,
                        y: r.rendimento
                    })),
                    backgroundColor: colors[colorIndex].bg,
                    borderColor: colors[colorIndex].border,
                    borderWidth: 1,
                    pointRadius: 0,
                    pointHoverRadius: 5,
                    periodoValue: periodo // Aggiungiamo il valore del periodo per riferimento
                });
            }

            // Troviamo il miglior rendimento complessivo (il pi√π alto tra tutti i periodi)
            let migliorRendimentoComplessivo = null;
            let migliorRendimentoCompletoInfo = null;

            for (let i = 0; i < tuttiMiglioriGiorni.length; i++) {
                const migliorGiorno = tuttiMiglioriGiorni[i];
                if (migliorRendimentoComplessivo === null || migliorGiorno.rendimento > migliorRendimentoComplessivo) {
                    migliorRendimentoComplessivo = migliorGiorno.rendimento;
                    migliorRendimentoCompletoInfo = {
                        periodo: migliorGiorno.periodo,
                        giorno: migliorGiorno.giorno,
                        rendimento: migliorGiorno.rendimento,
                        rendimentoAnnuo: migliorGiorno.rendimentoAnnuo,
                        datasetIndex: tuttiRendimenti.findIndex(r => r.periodo === migliorGiorno.periodo) // Salviamo l'indice del dataset corrispondente
                    };
                }
            }

            // Troviamo il miglior rendimento annuo (il pi√π alto tra tutti i periodi)
            let migliorRendimentoAnnuoComplessivo = null;
            let migliorRendimentoAnnuoInfo = null;

            for (let i = 0; i < tuttiMiglioriGiorniAnnui.length; i++) {
                const migliorGiornoAnnuo = tuttiMiglioriGiorniAnnui[i];
                if (migliorRendimentoAnnuoComplessivo === null || migliorGiornoAnnuo.rendimentoAnnuo > migliorRendimentoAnnuoComplessivo) {
                    migliorRendimentoAnnuoComplessivo = migliorGiornoAnnuo.rendimentoAnnuo;
                    migliorRendimentoAnnuoInfo = {
                        periodo: migliorGiornoAnnuo.periodo,
                        giorno: migliorGiornoAnnuo.giorno,
                        rendimento: migliorGiornoAnnuo.rendimento,
                        rendimentoAnnuo: migliorGiornoAnnuo.rendimentoAnnuo,
                        datasetIndex: tuttiRendimenti.findIndex(r => r.periodo === migliorGiornoAnnuo.periodo) // Salviamo l'indice del dataset corrispondente
                    };
                }
            }

            // Aggiungiamo il punto per il miglior rendimento complessivo
            if (migliorRendimentoCompletoInfo) {
                const periodoFormattato = formattaPeriodo(migliorRendimentoCompletoInfo.periodo);
                const periodoIndex = migliorRendimentoCompletoInfo.datasetIndex;
                // Utilizziamo lo stesso colore della serie di rendimenti corrispondente
                const colorIndex = periodoIndex % colors.length;
                const coloreBordo = colors[colorIndex].border;
                const coloreSfondo = colors[colorIndex].bg;

                datasets.push({
                    label: `_hidden_miglior_rendimento`, // Nome speciale per identificarlo
                    data: [{ x: migliorRendimentoCompletoInfo.giorno, y: migliorRendimentoCompletoInfo.rendimento }],
                    backgroundColor: coloreBordo, // Usa lo stesso colore della serie
                    borderColor: coloreBordo, // Usa lo stesso colore della serie
                    borderWidth: 1,
                    pointRadius: 4,
                    pointHoverRadius: 6,
                    order: -1, // Valore pi√π basso per essere disegnato sopra (in primo piano)
                    z: 10, // Valore pi√π alto per essere in primo piano
                    showLine: false,
                    fill: false,
                    pointStyle: 'circle',
                    periodoValue: migliorRendimentoCompletoInfo.periodo, // Aggiungiamo il valore del periodo per riferimento
                    periodoIndex: migliorRendimentoCompletoInfo.datasetIndex, // Indice del dataset principale
                    hidden: false // Inizialmente il punto √® visibile
                });
            }

            // Aggiungiamo il punto per il miglior rendimento annuo
            if (migliorRendimentoAnnuoInfo) {
                const periodoFormattato = formattaPeriodo(migliorRendimentoAnnuoInfo.periodo);
                datasets.push({
                    label: `_hidden_miglior_rendimento_annuo`, // Nome speciale per identificarlo
                    data: [{ x: migliorRendimentoAnnuoInfo.giorno, y: migliorRendimentoAnnuoInfo.rendimento }],
                    backgroundColor: 'rgba(0, 0, 255, 1)',
                    borderColor: 'rgba(0, 0, 255, 1)',
                    borderWidth: 1,
                    pointRadius: 4,
                    pointHoverRadius: 6,
                    order: -2, // Valore pi√π basso per essere disegnato sopra (in primo piano)
                    z: 10, // Valore pi√π alto per essere in primo piano
                    showLine: false,
                    fill: false,
                    pointStyle: 'circle',
                    periodoValue: migliorRendimentoAnnuoInfo.periodo, // Aggiungiamo il valore del periodo per riferimento
                    periodoIndex: migliorRendimentoAnnuoInfo.datasetIndex, // Indice del dataset principale
                    hidden: false // Inizialmente il punto √® visibile
                });
            }

            // Memorizziamo gli indici dei dataset speciali per riferimento
            const pallinoRossoIndex = datasets.findIndex(d => d.label === '_hidden_miglior_rendimento');
            const pallinoBluIndex = datasets.findIndex(d => d.label === '_hidden_miglior_rendimento_annuo');

            returnsChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    elements: {
                        point: {
                            radius: 0, // Rimuove i punti dal grafico
                            hoverRadius: 7 // Mostra i punti solo al passaggio del mouse
                        },
                        line: {
                            tension: 0.4 // Aggiunge una leggera curva per rendere la linea pi√π fluida
                        }
                    },
                    plugins: {
                        annotation: {
                            annotations: {
                                zeroLine: {
                                    type: 'line',
                                    yMin: 0,
                                    yMax: 0,
                                    borderColor: 'black',
                                    borderWidth: 2,
                                    borderDash: [5, 5],
                                    drawTime: 'beforeDatasetsDraw'
                                }
                            }
                        },
                        title: {
                            display: true,
                            text: 'Rendimenti per Diversi Periodi di Investimento',
                            font: { size: 16 }
                        },
                        legend: {
                            labels: {
                                filter: function (legendItem, chartData) {
                                    // Nascondi elementi speciali dalla legenda
                                    return !legendItem.text.startsWith('_hidden_');
                                }
                            },
                            onClick: function (e, legendItem, legend) {
                                // Implementazione personalizzata dell'evento click sulla legenda
                                const index = legendItem.datasetIndex;
                                const chart = legend.chart;
                                const meta = chart.getDatasetMeta(index);

                                // Alterna la visibilit√† del dataset principale
                                meta.hidden = meta.hidden === null ? !chart.data.datasets[index].hidden : null;

                                // Gestione dei punti speciali (pallini rosso e blu)
                                if (pallinoRossoIndex >= 0 && datasets[pallinoRossoIndex].periodoIndex === index) {
                                    // Se questo √® il dataset associato al pallino rosso
                                    const metaPallinoRosso = chart.getDatasetMeta(pallinoRossoIndex);
                                    metaPallinoRosso.hidden = meta.hidden;
                                }

                                if (pallinoBluIndex >= 0 && datasets[pallinoBluIndex].periodoIndex === index) {
                                    // Se questo √® il dataset associato al pallino blu
                                    const metaPallinoBlu = chart.getDatasetMeta(pallinoBluIndex);
                                    metaPallinoBlu.hidden = meta.hidden;
                                }

                                // Aggiorna il grafico
                                chart.update();
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const point = context.raw;
                                    const date = new Date(point.x);

                                    // Cerchiamo la data di uscita corrispondente nei dati originali
                                    let dataUscita = null;
                                    const datasetIndex = context.datasetIndex;
                                    const datasetLabel = context.dataset.label;

                                    // Se √® un punto normale (non un punto speciale come miglior rendimento)
                                    if (datasetLabel.includes('Rendimenti (')) {
                                        // Troviamo il periodo corrispondente dal label (es. "Rendimenti (5 anni)")
                                        const periodoMatch = datasetLabel.match(/\((.*?)\)/);
                                        if (periodoMatch && periodoMatch[1]) {
                                            const periodoFormattato = periodoMatch[1];
                                            const periodo = context.dataset.periodoValue;

                                            // Troviamo i dati originali per questo periodo
                                            const periodoData = tuttiRendimenti.find(r => r.periodo === periodo);
                                            if (periodoData) {
                                                // Troviamo il rendimento specifico per questa data di ingresso
                                                const rendimento = periodoData.rendimentiArray.find(r =>
                                                    r.data_ingresso.getTime() === date.getTime());
                                                if (rendimento) {
                                                    dataUscita = rendimento.data_uscita;
                                                }
                                            }
                                        }
                                    }

                                    // Se abbiamo trovato la data di uscita, la mostriamo
                                    if (dataUscita) {
                                        const dataIngressoFormattata = date.toLocaleDateString('it-IT', { day: '2-digit', month: 'long', year: 'numeric' });
                                        const dataUscitaFormattata = dataUscita.toLocaleDateString('it-IT', { day: '2-digit', month: 'long', year: 'numeric' });
                                        return `Intervallo: ${dataIngressoFormattata} - ${dataUscitaFormattata}, Rendimento: ${point.y.toFixed(2)}%`;
                                    } else {
                                        // Fallback al comportamento originale
                                        return `Data: ${date.toLocaleDateString('it-IT', { day: '2-digit', month: 'short', year: 'numeric' })}, Rendimento: ${point.y.toFixed(2)}%`;
                                    }
                                },
                                title: function (tooltipItems) {
                                    const date = new Date(tooltipItems[0].raw.x);
                                    return date.toLocaleDateString('it-IT', { day: '2-digit', month: 'long', year: 'numeric' });
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'month',
                                displayFormats: {
                                    month: 'MMM YYYY'
                                }
                            },
                            title: {
                                display: true,
                                text: 'Data di Ingresso'
                            }
                        },
                        y: {
                            type: usaScalaLogaritmica ? 'logarithmic' : 'linear',
                            title: {
                                display: true,
                                text: 'Rendimento'
                            }
                        }
                    }
                }
            });
        }

        // Funzione per creare il grafico del prezzo
        function createPriceChart(dates, leveragedData, tuttiMiglioriGiorni, tuttiMiglioriGiorniAnnui) {
            // Prepariamo i dati per il grafico
            const data = [];
            for (let i = 0; i < dates.length && i < leveragedData.length; i++) {
                data.push({
                    x: dates[i],
                    y: leveragedData[i]
                });
            }

            // Definiamo una palette di colori per i diversi periodi
            // Colori predefiniti per i diversi periodi - deve corrispondere ai colori usati nel grafico dei rendimenti
            const colors = [
                { bg: 'rgba(0, 123, 255, 0.5)', border: 'rgba(0, 123, 255, 1)' },  // Blu
                { bg: 'rgba(40, 167, 69, 0.5)', border: 'rgba(40, 167, 69, 1)' },    // Verde
                { bg: 'rgba(220, 53, 69, 0.5)', border: 'rgba(220, 53, 69, 1)' },     // Rosso
                { bg: 'rgba(255, 193, 7, 0.5)', border: 'rgba(255, 193, 7, 1)' },     // Giallo
                { bg: 'rgba(111, 66, 193, 0.5)', border: 'rgba(111, 66, 193, 1)' },   // Viola
                { bg: 'rgba(23, 162, 184, 0.5)', border: 'rgba(23, 162, 184, 1)' }     // Ciano
            ];

            // Verifichiamo che ci siano dati validi per i migliori giorni
            const annotations = {};

            // Distruggiamo il grafico esistente se presente
            if (priceChartInstance) {
                priceChartInstance.destroy();
            }

            // Calcoliamo il numero totale di periodi (normali + annui) per distribuire le frecce
            const numeroPeriodi = tuttiMiglioriGiorni.length;

            // Definiamo valori fissi per il posizionamento delle frecce
            // Questi valori saranno costanti indipendentemente dalla scala
            const valoreBase = 0;  // Valore di partenza sopra il 100%
            const spazioDisponibile = 400; // Range di valori per le frecce

            // Creiamo le annotazioni per tutti i periodi
            // Iteriamo su tutti i periodi per i migliori rendimenti assoluti
            for (let i = 0; i < tuttiMiglioriGiorni.length; i++) {
                const periodo = tuttiMiglioriGiorni[i].periodo;
                const giorno = tuttiMiglioriGiorni[i].giorno;
                const dataUscita = tuttiMiglioriGiorni[i].dataUscita;
                const colorIndex = i % colors.length;

                // Calcoliamo la posizione verticale con valori fissi
                // Distribuiamo equamente basandoci sul numero di periodi
                const altezzaFreccia = valoreBase + (spazioDisponibile * (i + 1) / (numeroPeriodi + 1));

                // Aggiungiamo l'annotazione per il giorno di ingresso
                annotations[`migliorGiorno_${i}`] = {
                    type: 'line',
                    xMin: giorno,
                    xMax: giorno,
                    borderColor: colors[colorIndex].border,
                    borderWidth: 3,
                    label: {
                        content: `Ingresso ${formattaPeriodo(periodo)}`,
                        enabled: true,
                        position: 'start'
                    }
                };

                // Aggiungiamo l'annotazione per il giorno di uscita
                annotations[`migliorDataUscita_${i}`] = {
                    type: 'line',
                    xMin: dataUscita,
                    xMax: dataUscita,
                    borderColor: colors[colorIndex].border,
                    borderWidth: 3,
                    label: {
                        content: `Uscita ${formattaPeriodo(periodo)}`,
                        enabled: true,
                        position: 'start'
                    }
                };

                // Aggiungiamo una freccia che collega l'inizio e la fine del periodo
                // Utilizziamo valori numerici fissi per yMin e yMax cos√¨ da creare una linea orizzontale
                annotations[`frecciaPeriodo_${i}`] = {
                    type: 'line',
                    xMin: giorno,
                    xMax: dataUscita,
                    yMin: altezzaFreccia,
                    yMax: altezzaFreccia,
                    borderColor: colors[colorIndex].border,
                    borderWidth: 2,
                    z: 10, // Z-index elevato per assicurarsi che le frecce appaiano sopra tutto
                    arrowHeads: {
                        end: {
                            display: true,
                            borderColor: colors[colorIndex].border,
                            borderWidth: 2,
                            length: 10,
                            width: 5
                        }
                    }
                };
            }

            // Iteriamo su tutti i periodi per i migliori rendimenti annui
            for (let i = 0; i < tuttiMiglioriGiorniAnnui.length; i++) {
                const periodo = tuttiMiglioriGiorniAnnui[i].periodo;
                const giorno = tuttiMiglioriGiorniAnnui[i].giorno;
                const dataUscita = tuttiMiglioriGiorniAnnui[i].dataUscita;
                const colorIndex = i % colors.length;

                // Aggiungiamo l'annotazione per il giorno di ingresso annuo
                annotations[`migliorGiornoAnnuo_${i}`] = {
                    type: 'line',
                    xMin: giorno,
                    xMax: giorno,
                    borderColor: colors[colorIndex].border,
                    borderWidth: 3,
                    label: {
                        content: `Ingresso Annuo ${formattaPeriodo(periodo)}`,
                        enabled: true,
                        position: 'end'
                    }
                };

                // Aggiungiamo l'annotazione per il giorno di uscita annuo
                annotations[`migliorDataUscitaAnnuo_${i}`] = {
                    type: 'line',
                    xMin: dataUscita,
                    xMax: dataUscita,
                    borderColor: colors[colorIndex].border,
                    borderWidth: 3,
                    label: {
                        content: `Uscita Annuo ${formattaPeriodo(periodo)}`,
                        enabled: true,
                        position: 'end'
                    }
                };
            }

            // Verifichiamo se la scala logaritmica √® attiva
            const usaScalaLogaritmica = document.getElementById('scala_logaritmica_prezzo').checked;

            // Creiamo il nuovo grafico
            const ctx = document.getElementById('priceChart').getContext('2d');
            priceChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [
                        {
                            label: 'Prezzo con Leva',
                            data: data,
                            borderColor: 'rgba(40, 167, 69, 1)',
                            backgroundColor: 'rgba(40, 167, 69, 0.1)',
                            fill: false,
                            borderWidth: 1,
                            pointRadius: 0,
                            pointHoverRadius: 5,
                            tension: 0.4
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Variazione percentuale nel Periodo Analizzato',
                            font: { size: 16 }
                        },
                        annotation: {
                            annotations: {
                                ...annotations,
                                lineaRiferimento100: {
                                    type: 'line',
                                    yMin: 100,
                                    yMax: 100,
                                    borderColor: 'rgba(0, 0, 0, 0.5)',
                                    borderWidth: 2,
                                    borderDash: [5, 5],
                                    label: {
                                        content: '100%',
                                        enabled: true,
                                        position: 'start'
                                    }
                                }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                title: function (tooltipItems) {
                                    const date = new Date(tooltipItems[0].raw.x);
                                    return date.toLocaleDateString('it-IT', { day: '2-digit', month: 'short', year: 'numeric' });
                                },
                                label: function (tooltipItem) {
                                    const leva = parseFloat(document.getElementById('leva').value);
                                    if (leva === 1) {
                                        return `Rispetto all'inizio: ${(tooltipItem.raw.y - 100).toFixed(2)} %`;
                                    } else {
                                        return `Rispetto all'inizio con leva ${leva.toFixed(1)}: ${(tooltipItem.raw.y - 100).toFixed(2)} %`;
                                    }
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'month',
                                displayFormats: {
                                    month: 'MMM YYYY'
                                }
                            },
                            title: {
                                display: true,
                                text: 'Data'
                            }
                        },
                        y: {
                            type: usaScalaLogaritmica ? 'logarithmic' : 'linear',
                            title: {
                                display: true,
                                text: 'Valore'
                            }
                        }
                    }
                }
            });
        }

        // Funzione per aggiornare la tabella delle statistiche
        function updateStatsTable(stats) {
            const tbody = document.getElementById('stats-body');
            tbody.innerHTML = '';

            // Aggiorniamo lo stile della tabella per gestire meglio le colonne
            const table = document.getElementById('stats-table');
            table.style.tableLayout = 'auto'; // Permette alle colonne di adattarsi al contenuto
            table.style.width = '100%';
            table.style.maxWidth = '100%';
            table.style.borderCollapse = 'collapse';

            // Se stats √® un array di oggetti, dobbiamo creare una tabella con periodi per righe
            if (Array.isArray(stats) && stats.length > 0) {
                // Ordiniamo l'array di statistiche per durata del periodo (dal pi√π breve al pi√π lungo)
                stats.sort((a, b) => a.periodoRaw - b.periodoRaw);

                // Otteniamo tutte le chiavi (metriche) dal primo oggetto, escludendo le propriet√† tecniche
                const metriche = Object.keys(stats[0]).filter(metrica =>
                    metrica !== 'Mesi' && metrica !== 'periodoRaw' && metrica !== 'isPeriodoGlobale');

                // Creiamo la riga di intestazione con tutte le colonne
                const headerRow = document.createElement('tr');
                headerRow.style.backgroundColor = '#e9ecef';

                // Aggiungiamo le celle di intestazione per ogni metrica
                metriche.forEach(metrica => {
                    const metricaHeaderCell = document.createElement('th');
                    metricaHeaderCell.style.padding = '10px';
                    metricaHeaderCell.style.textAlign = 'center'; // Centro il testo delle intestazioni
                    metricaHeaderCell.style.border = '1px solid #dee2e6';
                    metricaHeaderCell.style.verticalAlign = 'top';
                    metricaHeaderCell.style.whiteSpace = 'normal'; // Permette il wrapping del testo
                    metricaHeaderCell.style.wordBreak = 'normal'; // Non spezza le parole
                    metricaHeaderCell.style.wordWrap = 'break-word'; // Specifica aggiuntiva
                    metricaHeaderCell.style.overflowWrap = 'anywhere'; // Controllo aggiuntivo per l'overflow
                    metricaHeaderCell.style.lineHeight = '1.2'; // Altezza riga pi√π compatta per l'intestazione

                    // Imposta larghezza fissa per la colonna Periodo
                    if (metrica === 'Periodo') {
                        metricaHeaderCell.style.width = 'auto';
                        metricaHeaderCell.style.minWidth = '120px';
                        metricaHeaderCell.style.fontWeight = 'bold';
                    }

                    metricaHeaderCell.textContent = metrica;
                    headerRow.appendChild(metricaHeaderCell);
                });

                tbody.appendChild(headerRow);

                // Creiamo una riga per ogni periodo
                stats.forEach((statObj, index) => {
                    const row = document.createElement('tr');

                    // Se questo √® il periodo massimo globale, applichiamo uno stile speciale
                    if (statObj.isPeriodoGlobale) {
                        row.style.backgroundColor = '#d4e6fe'; // Blu scuro
                    }

                    // Aggiungiamo una cella per ogni metrica di questo periodo
                    metriche.forEach(metrica => {
                        const valueCell = document.createElement('td');
                        valueCell.style.padding = '8px';
                        valueCell.style.border = '1px solid #dee2e6';
                        valueCell.style.textAlign = 'left';
                        valueCell.style.verticalAlign = 'middle';
                        valueCell.style.whiteSpace = 'nowrap'; // Impedisce il wrapping del testo nei dati

                        // Mettiamo in grassetto la colonna "Periodo"
                        if (metrica === 'Periodo') {
                            valueCell.style.fontWeight = 'bold';
                            valueCell.style.width = 'auto'; // Larghezza automatica per adattarsi al contenuto
                            valueCell.style.minWidth = '120px'; // Larghezza minima per garantire leggibilit√†
                        }

                        // Usa direttamente il valore senza manipolazioni, dato che √® gi√† formattato in periodoObj
                        valueCell.textContent = statObj[metrica] || '-';
                        row.appendChild(valueCell);
                    });

                    tbody.appendChild(row);
                });
            } else if (typeof stats === 'object' && stats !== null) {
                // Caso di un singolo oggetto (per retrocompatibilit√†)
                // Convertiamo in array e richiamiamo la stessa funzione
                updateStatsTable([stats]);
            }
        }

        // Funzione per inizializzare la gestione dei periodi
        function initPeriodi() {
            // Aggiungiamo alcuni valori predefiniti (es. 1 anno, 5 anni)
            aggiungiPeriodo(1, 0, 0); // 1 anno
            aggiungiPeriodo(5, 0, 0); // 5 anni

            // Aggiungiamo evento al pulsante "+" della prima riga
            document.querySelector('.add-periodo-btn').addEventListener('click', function () {
                const row = this.closest('.periodo-row');
                const anni = row.querySelector('[data-unit="anni"]').value || 0;
                const mesi = row.querySelector('[data-unit="mesi"]').value || 0;
                const giorni = row.querySelector('[data-unit="giorni"]').value || 0;

                // Aggiungiamo un nuovo periodo solo se almeno uno dei campi √® compilato
                if (anni > 0 || mesi > 0 || giorni > 0) {
                    aggiungiPeriodo(anni, mesi, giorni);

                    // Resettiamo i campi di input
                    row.querySelector('[data-unit="anni"]').value = '';
                    row.querySelector('[data-unit="mesi"]').value = '';
                    row.querySelector('[data-unit="giorni"]').value = '';
                }
            });

            // Attiviamo l'aggiornamento del campo nascosto quando un periodo cambia
            document.querySelectorAll('.periodo-row').forEach(row => {
                row.querySelectorAll('input').forEach(input => {
                    input.addEventListener('change', aggiornaCampoPeriodi);
                });
            });

            // Aggiorniamo il campo nascosto con i periodi iniziali
            aggiornaCampoPeriodi();
        }

        // Funzione per aggiungere un nuovo periodo
        function aggiungiPeriodo(anni, mesi, giorni) {
            // Creiamo l'elemento del periodo
            const periodoRow = document.createElement('div');
            periodoRow.className = 'periodo-row aggiunto';
            periodoRow.style.display = 'flex';
            periodoRow.style.alignItems = 'center';
            periodoRow.style.marginBottom = '10px';
            periodoRow.style.padding = '10px';
            periodoRow.style.backgroundColor = '#f0f9ff';
            periodoRow.style.borderRadius = '8px';
            periodoRow.style.border = '1px solid #d0e8ff';

            // Calcoliamo la data di fine basata sul periodo
            const dataInizio = document.getElementById('data_inizio').value;
            let dataFine = calcolaDataFine(dataInizio, anni, mesi, giorni);
            const formatoData = dataFine.toLocaleDateString('it-IT', { day: '2-digit', month: '2-digit', year: 'numeric' });

            // Generiamo il testo del periodo
            let periodoTesto = '';
            if (anni > 0) periodoTesto += anni + (anni === 1 ? ' anno ' : ' anni ');
            if (mesi > 0) periodoTesto += mesi + (mesi === 1 ? ' mese ' : ' mesi ');
            if (giorni > 0) periodoTesto += giorni + (giorni === 1 ? ' giorno' : ' giorni');

            // Sistemiamo il testo del periodo se √® vuoto
            if (periodoTesto === '') periodoTesto = 'Periodo personalizzato';

            // Aggiungiamo il testo al periodo
            periodoRow.innerHTML = `
                <div style="flex: 1; font-weight: 500;">${periodoTesto}</div>
                <input type="hidden" class="periodo-value" data-anni="${anni}" data-mesi="${mesi}" data-giorni="${giorni}">
                <button class="remove-periodo-btn" style="background-color: #dc3545; color: white; border: none; border-radius: 8px; padding: 8px 12px; cursor: pointer; margin-left: 10px;">√ó</button>
            `;

            // Aggiungiamo il periodo al container
            const periodiContainer = document.getElementById('periodi_container');
            periodiContainer.appendChild(periodoRow);

            // Aggiungiamo la classe 'aggiunto' per lo stile
            periodoRow.classList.add('aggiunto');

            // Aggiungiamo l'event listener per il pulsante di rimozione
            periodoRow.querySelector('.remove-periodo-btn').addEventListener('click', function () {
                periodoRow.remove();
                aggiornaCampoPeriodi();
            });

            // Aggiorniamo il campo nascosto con i periodi
            aggiornaCampoPeriodi();
        }

        // Funzione per calcolare la data di fine basata sul periodo
        function calcolaDataFine(dataInizio, anni, mesi, giorni) {
            const data = new Date(dataInizio);
            data.setFullYear(data.getFullYear() + parseInt(anni));
            data.setMonth(data.getMonth() + parseInt(mesi));
            data.setDate(data.getDate() + parseInt(giorni));
            return data;
        }

        // Funzione per aggiornare il campo nascosto con i periodi
        function aggiornaCampoPeriodi() {
            const periodi = [];
            document.querySelectorAll('.periodo-value').forEach(input => {
                const anni = parseFloat(input.getAttribute('data-anni') || 0);
                const mesi = parseFloat(input.getAttribute('data-mesi') || 0);
                const giorni = parseFloat(input.getAttribute('data-giorni') || 0);

                // Convertiamo tutto in anni
                const totaleAnni = anni + (mesi / 12) + (giorni / 365.25);
                if (totaleAnni > 0) {
                    periodi.push(totaleAnni);
                }
            });

            // Aggiorniamo il campo nascosto
            document.getElementById('periodi_investimento').value = periodi.join(',');
        }

        // Funzione per formattare il periodo in anni, mesi e giorni
        function formattaPeriodo(periodoAnni) {
            // Scomponiamo il periodo
            const anniInteri = Math.floor(periodoAnni);
            const meseDecimale = (periodoAnni - anniInteri) * 12;
            const mesiInteri = Math.floor(meseDecimale);
            const giorni = Math.round((meseDecimale - mesiInteri) * 30.4375); // Media giorni per mese

            // Formattiamo il testo
            let periodoTesto = '';
            if (anniInteri > 0) periodoTesto += anniInteri + (anniInteri === 1 ? ' anno ' : ' anni ');
            if (mesiInteri > 0) periodoTesto += mesiInteri + (mesiInteri === 1 ? ' mese ' : ' mesi ');
            if (giorni > 0) periodoTesto += giorni + (giorni === 1 ? ' giorno' : ' giorni');

            // Se periodo √® molto breve (meno di un giorno)
            if (periodoTesto === '') periodoTesto = 'meno di 1 giorno';

            return periodoTesto.trim();
        }
    </script>
</body>

</html>